abstract type boolean {}
type true:boolean { }
type false:boolean {}
const true true {}
const false false {}
type * naturel { }
const zero naturel {}
const  un *naturel {next=zero}
type *suite { naturel:val }


function + naturel:a naturel:b | if a is *naturel then *naturel { next=a.next+b } else b

function * naturel:a naturel:b | if a is *naturel then   a.next*b + b else b

function  red nature:a naturel:b naturel:ib naturel:c |  
	if a is !   *naturel  then 
		c  
	else if b is *naturel then 
		red(a.next b.next ib c)
	else 
		red(a ib ib c.next) 


 
function / naturel:a naturel:b | red(a b b naturel {} )
function & boolean:a boolean:b | if a is true then b else false
function positif naturel:a | if a is *naturel then true else false 

function = naturel:a naturel:b |	
	if a is *naturel  then 
		(if b is *naturel then a.next=b.next  else false)
	else if b is *naturel then 
		false 
	else 
		true

function produit suite:suite | if suite is *suite then suite.val*produit(suite.next) else un

function estSuitePremier suite:suite | 
	if suite is *suite then 
		(if estPremier(suite.val) is 
			true 
		then 
			estSuitePremier(suite.next) 
		else 
			false ) 
	else 
		true


function estPremier naturel:x | if x is ! *naturel then false else  testPremier(x x.next)
function testPremier naturel:x naturel:diviseur | 
	if diviseur is ! *naturel then 
		true 
	else if ( diviseur*(x/diviseur)=x ) is true  then  
		false 
	else
		testPremier(x diviseur.next )

predicat  commu  | All naturel:x naturel:y | ( x+y = y+x  ) is true





				
	

							 












				
	

							 


































































